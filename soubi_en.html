<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Spec Input Tool</title>
  <style>
    html, body { height: 100%; margin: 0; }
    #app { width: 100%; height: 100%; border: 0; display: block; }
  </style>
</head>
<body>
  <!-- 日本語版をそのまま読み込み（見た目・機能は完全同じ） -->
  <iframe id="app" src="soubi.html?v=10" title="Spec Input Tool"></iframe>

  <script>
  (function () {
    const replacements = new Map([
      ["装備入力ツール","Spec Input Tool"],
      ["装備入力","Spec Input"],
      ["スペック入力","Spec Input"],
      ["仕様入力","Spec Input"],
      ["装備を選択してください","Select specs below"],
      ["必要な装備を選んでください","Select the required specs"],
      ["下のボタンを押して追加","Tap buttons below to add"],
      ["手動入力","Manual Input"],
      ["手動入力欄","Manual Input"],
      ["自由入力","Free Input"],
      ["コピー","COPY"],            // ボタン表示
      ["COPYしました！","Copied!"],  // soubi.htmlでの英日混在対応
      ["コピーしました！","Copied!"], // 完全日本語バージョンも対応
      ["コピーしました","Copied!"],   // 末尾に！がない場合も対応
      ["全削除","CLEAR"],
      ["全てClear","CLEAR"],
      ["削除","Delete Last"],
      ["クリア","Clear"],
      ["アンドゥ","Undo"],
      ["やり直し","Redo"],
      ["並び替え","Sort"],
      ["幅を揃える","Align Width"],
      ["幅を自動調整","Auto Width"],
      ["削除しました","Deleted."],
      ["最後の項目を削除しました","Deleted the last item."],
      ["全てクリアしました","Cleared all."],
      ["重複です","Duplicate."],
      ["すでに追加されています","Already added."],
      ["入力してください","Please enter a value."],
      ["全削除しますか？","Do you want to clear all specs?"],
      ["本当に削除しますか？","Are you sure you want to delete this?"],
      ["同時に選択できません","Cannot select simultaneously"],
      ["既に選択されています","Already selected"],
      ["削除しますか？","Do you want to delete this?"],
      ["選択肢がありません","No selectable items"],
      ["追加しました","Added!"],
      ["有効な入力ではありません","Invalid input."],
      ["キャンセルされました","Cancelled."],
      ["選択できません","Cannot select this item."],
      ["確認","Confirm"],
      ["はい","Yes"],
      ["いいえ","No"],
      ["選択中","Selected"],
      ["結果","Result"],
      ["装備一覧","Spec List"],
      ["コピー用テキスト","Text to Copy"]
    ]);

    const placeholderReplacements = new Map([
      ["ここに入力","Type here"],
      ["手入力で追加","Add manually"],
      ["検索","Search"]
    ]);

    // 🔧 特殊翻訳対応：「〇〇は〇〇と同時に選択できません」→「Cannot select 〇〇 and 〇〇 at once」
    function replaceText(str) {
      if (!str) return str;
      let out = str;

      const simultaneousPattern = /(.*?)は(.*?)と同時に選択できません/;
      if (simultaneousPattern.test(out)) {
        out = out.replace(simultaneousPattern, "Cannot select $1 and $2 at once");
      }

      for (const [jp, en] of replacements) {
        if (out.includes(jp)) out = out.split(jp).join(en);
      }
      return out;
    }

    function translateDoc(doc) {
      try {
        if (doc.title) doc.title = replaceText(doc.title);
        document.title = "Spec Input Tool";
      } catch (e) {}

      const walker = doc.createTreeWalker(doc.body, NodeFilter.SHOW_TEXT, {
        acceptNode(node) {
          const t = node.nodeValue && node.nodeValue.trim();
          if (!t) return NodeFilter.FILTER_REJECT;
          for (const [jp] of replacements) {
            if (t.includes(jp)) return NodeFilter.FILTER_ACCEPT;
          }
          if (/(.*?)は(.*?)と同時に選択できません/.test(t)) return NodeFilter.FILTER_ACCEPT;
          return NodeFilter.FILTER_REJECT;
        }
      });
      const nodes = [];
      while (walker.nextNode()) nodes.push(walker.currentNode);
      for (const node of nodes) node.nodeValue = replaceText(node.nodeValue);

      const all = doc.querySelectorAll('[placeholder], input, textarea, [aria-label]');
      for (const el of all) {
        const ph = el.getAttribute('placeholder');
        if (ph) {
          let phOut = ph;
          for (const [jp, en] of placeholderReplacements) {
            if (phOut.includes(jp)) phOut = phOut.split(jp).join(en);
          }
          if (phOut !== ph) el.setAttribute('placeholder', phOut);
        }
        const aria = el.getAttribute('aria-label');
        if (aria) {
          const ariaOut = replaceText(aria);
          if (ariaOut !== aria) el.setAttribute('aria-label', ariaOut);
        }
      }

      doc.querySelectorAll('h1,h2,header .title,.page-title').forEach(h=>{
        const out = replaceText(h.textContent);
        if (out !== h.textContent) h.textContent = out;
      });
    }

    function attachInterceptors(win) {
      const origAlert = win.alert.bind(win);
      const origConfirm = win.confirm.bind(win);
      const origPrompt = win.prompt.bind(win);

      win.alert = (msg) => origAlert(replaceText(String(msg)));
      win.confirm = (msg) => origConfirm(replaceText(String(msg)));
      win.prompt = (msg, defVal) => origPrompt(replaceText(String(msg)), defVal);

      const doc = win.document;
      let pending = false;
      const observer = new MutationObserver(() => {
        if (pending) return;
        pending = true;
        win.requestAnimationFrame(() => {
          try { translateDoc(doc); } finally { pending = false; }
        });
      });
      observer.observe(doc, { childList: true, subtree: true, characterData: true });

      doc.addEventListener('input', () => translateDoc(doc), true);
      doc.addEventListener('change', () => translateDoc(doc), true);

      translateDoc(doc);
      setTimeout(() => translateDoc(doc), 150);
      setTimeout(() => translateDoc(doc), 500);
      setTimeout(() => translateDoc(doc), 1200);
    }

    const frame = document.getElementById('app');
    frame.addEventListener('load', () => {
      try {
        const doc = frame.contentDocument;
        const win = frame.contentWindow;
        if (!doc || !win) return;
        attachInterceptors(win);
      } catch (e) {
        setTimeout(() => {
          try {
            const doc = frame.contentDocument;
            const win = frame.contentWindow;
            if (!doc || !win) return;
            attachInterceptors(win);
          } catch {}
        }, 150);
      }
    });
  })();
  </script>
</body>
</html>
